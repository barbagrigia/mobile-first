<!--
The `mobile-first` element takes "Mobile First" to a whole new level. If viewed
on a desktop or large mobile device, it will embed its content within a mock
image of a mobile device. This will allow your users to experience your site as
you originally intended.

Tip: try giving both `body` and `html` styles of 100% height and zero margin,
as this will allow your `mobile-first` experience to take up the whole page.

<b>Example</b>:

    <mobile-first>
      <h5>Your Page!</h5>
    </mobile-first>

@element mobile-first
@status alpha
@homepage http://github.com/samthor/mobile-first
-->

<polymer-element name="mobile-first" attributes="mobile orientation device">
<template>
<style>

  .hidden {
    display: none !important;
  }

  :host {
    display: block;
    height: 100%;
    overflow: hidden;
    min-height: calc(568px + 8px);
  }

  .vertical-mid {
    position: relative;
    height: 0;
    top: 50%;
    will-change: transform;
  }

  #backdrop {
    cursor: pointer;
    position: absolute;
    margin: auto;
    margin-top: -50%;
    width: 100%;
    min-width: 1200px;
    padding-bottom: 100%;
    border-radius: 1000px;
    background: rgba(0, 0, 0, 0.12);
  }

  #wrapper:active #device,
  #wrapper:active #static {
    pointer-events: none;
  }

  #device img {
    pointer-events: none;
    position: absolute;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    will-change: transform;
  }

  #device.drift {
    /** transition for 'drop' to aligned phone */
    transition: all 0.35s;
  }

  .screen {
    height: 100%;
    will-change: transform;
    overflow: hidden;
  }

  #main {
    /** internal screen transition */ 
    transition: all 0.4s;
  }

</style>

<div id="wrapper" class="vertical-mid stable">
  <div id="backdrop">
  </div>
  <div id="device" class="drift">
    <img id="dimg" />
    <div id="dwindow" class="screen">
      <!-- By default, content lives in faux-screen -->
      <div id="main"><content id="content"></content></div>
    </div>
  </div>
  <div id="static">
  </div>
</div>

</template>
<script>

(function() {

var Device = function(width, height, background, opt_scale) {
  this.width = width;
  this.height = height;
  this.background = background;
  this.scale = +opt_scale || 2;
};

var Devices = {
  'iphone5': new Device(320, 568, 'devices/iphone5.png', 2),
  'nexus5': new Device(360, 640, 'devices/nexus5.png', 2)
};

/**
 * Helper that returns the angle from the center of the element being touched
 * or interacted with, in radians.
 *
 * @param {Event!} event to examine
 * @return {number} angle from center
 */
function deltaAngle(event) {
  var width = event.target.offsetWidth;
  var height = event.target.offsetHeight;
  // TODO: touch events
  var d = {
    x: event.offsetX - width / 2,
    y: event.offsetY - height / 2
  }
  var len = Math.sqrt(d.x*d.x + d.y*d.y);
  var a = Math.acos(d.x / len);
  if (d.y > 0) {
    a = Math.PI + Math.PI - a;
  }
  return a;
}

/**
 * Positions the given element in its parent's center. Does this by abusing
 * the margin and the given size. The element cannot change size after this.
 */
function positionInCenter(elem, size) {
  var style = elem.style;
  style.position = 'absolute';
  style.left = '50%';
  style.top = '50%';
  style.width = size.width + 'px';
  style.height = size.height + 'px';
  style.marginLeft = -size.width / 2 + 'px';
  style.marginTop = -size.height / 2 + 'px';
}

function rotateTo(elem, rads, forceTransform) {
  if (!forceTransform) {
    var tr = elem.style.transform;
    var m = tr.match(/([-+\d\.]*)rad/);
    var prev = m ? parseFloat(m[1]) : 0;
    var delta = prev - rads;
    if (delta > Math.PI) {
      rads += Math.PI * 2;
    } else if (delta < -Math.PI) {
      rads -= Math.PI * 2;
    }
  }

  elem.style.transform = 'rotateZ(' + rads + 'rad)';
  elem.style.webkitTransform = elem.style.transform;
}

/**
 * Clamps the given radians value to [0, Math.PI * 2).
 */
function clampRads(rads) {
  while (rads >= Math.PI * 2) { rads -= Math.PI * 2; }
  while (rads < 0) { rads += Math.PI * 2; };
  return rads;
}

function orientationFromAngle(rads) {
  rads = clampRads(rads);

  var orientation = 'up';
  if (rads > Math.PI * 1.75) {
    // already ok, up
  } else if (rads > Math.PI * 1.25) {
    orientation = 'left';
  } else if (rads > Math.PI * 0.75) {
    orientation = 'down';
  } else if (rads > Math.PI * 0.25) {
    orientation = 'right';
  }
  return orientation;
}

function angleFromOrientation(orientation) {
  switch(orientation) {
  case 'left':
    return -Math.PI / 2;
  case 'right':
    return +Math.PI / 2;
  case 'down':
    return Math.PI;
  }
  return 0;
}

Polymer({

  /**
   * Width (or below) at which this element is recognized as a mobile device.
   */
  mobile: 768,

  /**
   * Orientation of device. The screen will always be rotated to face the
   * user's perspective.
   */
  orientation: 'up',

  /**
   * The device type to show.
   */
  device: null,
  defaultDevice_: null,

  created: function() {
    // choose random key from Devices
    var choices = Object.keys(Devices);
    this.defaultDevice_ = choices[Math.floor(Math.random() * choices.length)];
  },

  ready: function() {
    // TODO: Use a shrink/grow scroll hack listener to do this.
    window.addEventListener('resize', this.updateMobileFirst_.bind(this));
    this.updateDevice_();
    this.updateMobileFirst_();

    // Registers rotate handlers.
    (function(elem, callback) {
      var previousAngle;

      // TODO: touch listeners
      elem.addEventListener('mousemove', function(event) {
        if (!event.which) return;
        var angle = deltaAngle(event);
        if (previousAngle !== undefined) {
          var delta = previousAngle - angle;
          callback(delta);
        }
        previousAngle = angle;
      });

      function done() {
        previousAngle = undefined;
        callback();
      }

      elem.addEventListener('mouseup', done);
      elem.addEventListener('mouseout', done);
    }(this.$.backdrop, this.rotateBy_.bind(this)));
  },

  attributeChanged: function(attrName, oldVal, newVal) {
    switch (attrName) {
    case 'width':
      this.updateMobileFirst_();
      break;
    case 'device':
      this.updateDevice_();
      break;
    case 'orientation':
      this.updateOrientation_();
      break;
    }
  },

  updateDevice_: function() {
    var d = this.deviceObject;
    positionInCenter(this.$.dwindow, d);

    // Reload the device image.
    var img = this.$.dimg;
    img.style.display = 'none';
    img.src = '';
    img.onload = function() {
      positionInCenter(img, {
        width: img.width / d.scale,
        height: img.height / d.scale
      });
      img.style.display = '';
    }.bind(this);
    img.src = d.background;

    this.updateOrientation_();
  },

  updateOrientation_: function() {
    var d = this.deviceObject;
    var angle = angleFromOrientation(this.orientation);
    rotateTo(this.$.main, -angle);

    var screenSize = { width: d.width, height: d.height };
    if (this.orientation == 'left' || this.orientation == 'right') {
      screenSize = { width: screenSize.height, height: screenSize.width }; 
    }
    positionInCenter(this.$.main, screenSize);
    positionInCenter(this.$.static, screenSize);
    this.maybeAlignDevice_();
  },

  updateMobileFirst_: function() {
    var isMobile = this.isMobile;

    this.$.wrapper.classList.toggle('hidden', isMobile);
    if (isMobile) {
      this.shadowRoot.appendChild(this.$.content);
    } else if (this.staticPositionTimeout_) {
      this.$.main.appendChild(this.$.content);
      this.$.static.classList.add('hidden');
    } else {
      this.$.static.appendChild(this.$.content);
      this.$.static.classList.remove('hidden');
    }
  },

  /**
   * While this is truthy, only position the inner content within the deivce:
   * aka, potentially rotated twice (#device then #main).
   *
   * When it is false, we are confident that the content can be inserted within
   * the never-rotating static element.
   */
  staticPositionTimeout_: null,

  /**
   * Rotate by a relative delta (in radians). If no value is passed, this means
   * that a user gesture has stopped and that the device should orient towards
   * the current orientation.
   *
   * @param {number=} opt_delta to rotate by, or undefined for finished gesture
   * @private
   */
  rotateBy_: function(opt_delta) {
    if (this.isMobile) {
      return false;  // called after mock phone has gone away
    }

    window.clearTimeout(this.staticPositionTimeout_);
    this.staticPositionTimeout_ = true;

    if (opt_delta === undefined) {
      this.$.device.classList.add('drift');
      this.maybeAlignDevice_();
    } else {
      this.updateMobileFirst_();
      this.$.device.classList.remove('drift');
      this.currentAngle += opt_delta;
      this.setAttribute('orientation', orientationFromAngle(this.currentAngle));
    }
  },

  maybeAlignDevice_: function() {
    var withinGesture = !this.$.device.classList.contains('drift');
    if (withinGesture) {
      return;
    }
    var angle = angleFromOrientation(this.orientation);
    this.currentAngle = angle;

    this.staticPositionTimeout_ = window.setTimeout(function() {
      this.staticPositionTimeout_ = null;
      this.updateMobileFirst_();
    }.bind(this), 400);  /* matches #main transition */

    this.updateMobileFirst_();
  },

  currentAngle_: 0,

  set currentAngle(x) {
    var x = clampRads(x);
    this.currentAngle_ = x;
    rotateTo(this.$.device, x, !this.$.device.classList.contains('drift'));
  },

  get currentAngle() {
    return this.currentAngle_;
  },

  get isMobile() {
    //var isMobile = (typeof window.orientation !== 'undefined');
    var rect = this.getBoundingClientRect();
    return rect.width <= this.mobile || rect.height <= this.mobile / 2;
  },

  get deviceObject() {
    return Devices[this.device] || Devices[this.defaultDevice_];
  }

});

}());

</script>
</polymer-element>
